package Everything::NodeAccess;


use Moose::Policy 'Moose::Policy::FollowPBP';
use Moose;

extends 'Everything::Object';

has type_hierarchy => ( is => 'rw', isa => 'ArrayRef',  default => sub { [] } );

has default_accesses => ( accessor => 'default_accesses', isa => 'HashRef' );

has default_permissions => ( accessor => 'default_permissions', isa => 'HashRef' );
has usergroup => ( accessor => 'usergroup' );

has nb => ( accessor => 'nb', isa => 'Everything::NodeBase' );
has node => ( is =>'rw', weak_ref => 1  );

sub has_access {

	my ( $this, $USER, $modes ) = @_;

	# -1 is a way of specifying "super user".
	return 1 if ( $USER eq "-1" );

	# Gods always have access to everything
	return 1 if ( $USER->isGod() );

	my $create = 0;
	my $result = -1;

	# We need to check for create permissions separately
	$create = 1 if ( $modes =~ s/c//i );

	if ( $modes ne "" )
	{

		# Figure out what permissions this user has for this node.
		my $perms = $this->user_permissions($USER);

		$result = Everything::Security::checkPermissions( $perms, $modes );
	}

	if ($create)
	{

		# If one of the flags was the create flag we need to check it
		# against the permissions that are *not* the author permissions.
		# This is because author permissions do not have create flags.
		# Its kind of a chicken/egg thing.  How can you be the author
		# if it's not created yet?  If it is created and you are the
		# author, why do you need to check (it's already created!)?
		# So to get around this, we set the author user to be something
		# non-existant to force it to use one of the other permission
		# classes.
		my $author  = $$this{author_user};
		my $cresult = 0;

		$$this{author_user} = 0;

		my $perms = $this->user_permissions($USER);

		$modes   = "c";
		$cresult = Everything::Security::checkPermissions( $perms, $modes );

		# Set the author back
		$$this{author_user} = $author;

		if ( $result != -1 )
		{

			# We need to combine the 2 results (they both must be true)
			$result = ( $result && $cresult );
		}
		else
		{

			# This was a check on create only...
			$result = $cresult;
		}
	}

	return $result;


}

=head2 C<user_permissions>

Given the user and a node, this will return what permissions the user has on
that node.

=over 4

=item * NODE

The node for which we wish to check permissions

=item * USER

The user that to get permissions for.

=back

Returns a string that contains the permission flags that the user has access.
For example, if the user can read and write to the node, the return value will
be "rw".  If the user has no permissions for the node, an empty string ("")
will be returned.

=cut

sub user_permissions
{
	my ( $this, $USER ) = @_;
	my $perms = $this->dynamic_permissions($USER);

	my $node = $this->get_node;

	if ( not defined $perms )
	{
		my $class = $this->user_relation($USER);
		$perms = $node->{"${class}access"};
		my $parent_perms = $this->default_accesses->{$class};
		$perms = Everything::Security::inheritPermissions( $perms, $parent_perms );
	}

	# Remove any '-' chars and spaces, we only want the permissions of those
	# that are on.
	$perms =~ tr/- //d;

	return $perms;
}


=head2 C<dynamic_permissions>

You can specify a "permission" node to calculate the permissions for a node.
This checks to see if there is a permission for the node.  If so, it evals the
permission code and returns the generated permissions.

=over 4

=item * $USER

the user that is trying gain access

=back

Returns the permissions flags generated by the permission code

=cut

sub dynamic_permissions
{
	my ( $this, $USER ) = @_;
	my $class = $this->user_relation ($USER); # returns author, group or guest
	my $node = $this->get_node;
	my $permission = $node->{"dynamic${class}_permission"};

	$permission = $this->default_permissions->{"derived_default${class}_permission"}
		if $permission
		and $permission == -1;

	return unless $permission and $permission > 0;

	my $PERM = $this->nb->getNode($permission);
	return unless $PERM;

	## no critic
	my $perms = eval $PERM->{code};
	## use critic

	Everything::logErrors( '', $@, $PERM->{code}, $PERM ) if $@;
	return $perms;
}

=head2 C<user_relation>

Every user has some relation to every node.  They are either the "author", in
the "group", a "guest" user, or "other".  This will return the relation the
given user has with the given node.

=over 4

=item * $USER

the user

=back

Returns either "author", "group", "guest", or "other" which can be used to get
the appropriate permissions for the user.

=cut

sub user_relation
{
	my ( $this, $USER ) = @_;
	my $node = $this->get_node;
	my $class;
	my $userId;

	$userId = $USER->getId();

	# Determine how this user relates to this node.  Is the user
	# the author, in the group, "others", or guest user?
	if ( $userId == $$node{author_user} )
	{
		$class = "author";
	}
	elsif ( $USER->isGuest )
	{
		$class = "guest";
	}
	else
	{
		my $usergroup = $this->nb->getNode( $this->usergroup );

		if ( $usergroup && $usergroup->inGroup($USER) )
		{
			$class = "group";
		}
		else
		{

			# If the user is not the author, in the group, or the guest user
			# for the system, they must be "other".
			$class = "other";
		}
	}

	return $class;
}

sub determine_usergroup {

    my $self = shift;

    my $group_id;

    $group_id = $self->get_node->get_group_usergroup;

    return $group_id if $group_id && $group_id != -1;

    my $candidate;
    foreach  my $type ( @{ $self->get_type_hierarchy } ) {
	$candidate =  $$type{defaultgroup_usergroup};
	last if defined $candidate && $candidate != -1;
    }

    return $candidate;
}



1;
