#!/usr/bin/perl -w

########################################################################
#
#	nbmasta
#
#	"Nodeball Masta" -- the utility for managing nodeballs 
#
#	handles all importing, exporting, and updating of nodeballs
#	for the everything system, via XML files, and .nbz files
#
use strict;
use Everything;
use Everything::XML;

my $usagestr = "Usage: nbmasta [-v] [--force] (import|export|remove) <NODEBALL> <DATABASE>\n"; 
my %OPTIONS = ( force => 0, verbose => 0 );
while (@ARGV and $ARGV[0] =~ s/^\-(.*?)/$1/) {
	my $arg = shift @ARGV;
	if ($arg =~ s/^-(.*?)/$1/) {
		$OPTIONS{$arg}++ if exists ($OPTIONS{$arg});
		next;
	} 
	$OPTIONS{verbose}++ if ($arg =~ /v/);
}

if (@ARGV < 3) {
	print $usagestr; 
	exit;
}

my ($function, $nodeball, $database) = @ARGV[0..2];

initEverything($database, 1)
	or die "couldn't connect to $database";

#############################################################################
#	Function
#		exportTables
#
#	Purpose
#		This dumps the table structures in the given database using the
#		mysqldump utility.  We do not dump the table row data, since we
#		are using XML to store the database info.
#
sub exportTables {
	my ($tables, $dir) = @_;
	my $args = "--lock-tables --no-data";

	my $tbstr = join(" ", @$tables);

	# We need to make the directory writable, because mysql may be
	# running as the mysql user rather than root, and it will need
	# write permissions.
	my $mode = 0766;
	chmod $mode, $dir;

	my $err = `mysqldump -u root -T $dir $args $database $tbstr`;
	chomp $err;
	# do another chmod here so it's not as ugly?
	$err =~ s/^ *//g;  # clear out any whitespace

	if($err ne "") {
		print "mysqldump errors:\n" . $err;
		die unless $OPTIONS{force};
	}
}

#############################################################################
#	sub 
#		confirmYN
#
#	ask a yes no question (the sole parameter) return 0 if user answers false
#	(default) otherwise return 1
#
sub confirmYN {
	my ($q) = @_;
	print "$q";
	my $ans = <STDIN>;
	return 1 if $ans =~ /^y/i;
	return 0;
}


##############################################################################
#	sub
#		createDB
#
#	create a database of the given name
sub createDB{
	my ($dbname) = @_;
	$DB->getDatabaseHandle()->do("create database $dbname"); 
}

#############################################################################
#	sub
#		dropDB
#
#	drop a database (does not give warnings)
#
sub dropDB{
	my ($dbname) = @_;
   $DB->getDatabaseHandle()->do("drop database $dbname"); 
}

##########################################################################
#	sub
#		addTablesToDB	
#
#	adds specific tables to a database from a directory of create definitions
#	if no tables are specified, all are imported
#	Only tables listed in $TABLES array ref are used, if it's passed.	
sub addTablesToDB{
   my ($dbname, $tabledir, $TABLES) = @_;
   
	my %filter = map { $_ => 1 } @$TABLES;
	opendir DIR, $tabledir || die "can't opendir $tabledir $!";
	my $file; 
	my @tablefiles;
	while(defined($file=readdir(DIR))){
		if($file=~/(.*?)\.sql$/){
			my $tbname = $1;
			if ($TABLES) {
				next unless (defined($filter{$tbname}));
			}
	 		print "adding $tbname to $dbname\n" if $OPTIONS{verbose};
			system "mysql -u root $dbname<$tabledir/$file"; 
			push @tablefiles, $file; 
		}
	}
	closedir DIR; 
	return @tablefiles;
}

###########################################################################
#	sub
#		getTablesHashref
#
#	get the list of tables (actually a hash reference) for the given database
#
sub getTablesHashref{
   my ($db)=@_; 
   
   initEverything($db, 1); 
   my $st = $DB->getDatabaseHandle()->prepare("show tables");
   $st->execute;
   my %tables;
   while(my $ref=$st->fetchrow_arrayref){
      $tables{$ref->[0]}=1; 
   }
   return \%tables;
}

#######################################################################
#	sub
#		getColumns
#	
#	get the column information for a given table as a HOH 
#	with fieldname as key
#
sub getColumns {
	my ($table, $dbname) = @_;

	initEverything($dbname, 1); 
	my $st=$DB->getDatabaseHandle()->prepare("show columns from $table");    
	$st->execute;
	
	my %colhash;
	while(my $ref=$st->fetchrow_hashref){
		my $temp=$ref->{"Field"}; 
		foreach(keys %$ref){
			$colhash{$temp}{$_}=$ref->{$_}; 
		}
	}
	\%colhash;
}

########################################################################
#	sub
#		compareAllTables
#
#	compare the tables of the two database, making db1 the same as db2
#	or spitting out errors as to what the difference is.
#
#	params
#		checktab -- hashref of tables to be checked
#		dummytab -- hashref of tables to be checked against (assumed correct)
#		checkdb	-- name of db to be checked
#		dummydb -- name of db to check against
#		tabledir -- where all the tables are hiding
#
sub compareAllTables{
   my $ok=1;  
   my($checktab,$dummytab, $dummydb, $checkdb, $tabledir)=@_;
   foreach my $table (keys %$dummytab){
	   unless($checktab->{$table}){
		   print "$checkdb is missing the $table table -- adding it\n"; 
		   addTablesToDB($checkdb, $tabledir, [$table]);
		   next;
	   }
	 
	   my %dummyhash = %{ getColumns ($table, $dummydb) };
	   my %checkhash = %{ getColumns ($table, $checkdb) };
	   
	   foreach (keys %dummyhash){
		   if($checkhash{$_}){
			   foreach my $value(keys %{$dummyhash{$_}}){
					my $dummyval = $dummyhash{$_}{$value};
					if (exists ($checkhash{$_}) and 
						defined ($checkhash{$_}{$value}) and 
						$checkhash{$_}{$value} ne $dummyval){
					   $ok=0;
					   print "Discrepancy found\n";
					   print "\tTable: $table\n";
					   print "\tColumn: $_\n";
					   print "\tCategory $value\n";
					   print "\t$dummydb value=$dummyhash{$_}{$value} $checkdb value=$checkhash{$_}{$value}\n"; 
				   		#we would want to do an ALTER TABLE modify here
				  } 
			   } 
		   } else {
			   print "table $table in $checkdb is missing column $_\n";  
			   $ok=0;
			   #alter table add here
		   } 
	   } 
	   foreach (keys %checkhash) {
			next if ($dummyhash{$_});
			print "$checkdb table $table has extra column \"$_\"\n";
	   		#an extra table isn't necessarily bad
	   }
   }
   return $ok;
}

##########################################################################
#	sub
#		checkTables
#
#	checks to see if the tables in the target database are equivalent
#	to the tables in the sql files.  Does this by creating a dummy database
#	dumping the tables into it, and comparing them with show table and show
#	field statements.
#
sub checkTables {
	my ($tabledir) = @_;
	my $dummydb="dummy" . int(rand(1000));
	
	initEverything($database, 1);
	createDB $dummydb;
	addTablesToDB $dummydb, $tabledir;
	my $ret = compareAllTables(getTablesHashref($database),
		getTablesHashref($dummydb),  $dummydb, $database, $tabledir);
	dropDB $dummydb;
	
	initEverything($database, 1);
	$ret;
}

##########################################################################
#	sub
#		checkNamedTables
#
#	checks to see if the tables in the target database are equivalent
#	to the tables in the sql files.  Works just like checkTables, except
#	that it only checks files listed in the first argument, an array ref.
#
sub checkNamedTables {
	my ($tables_ref, $dir) = @_;
	my $dummydb="dummy" . int(rand(1000));
	
	initEverything($database, 1);
	createDB($dummydb);
	addTablesToDB($dummydb, $dir, $tables_ref);
	my $ret = compareAllTables(getTablesHashref($database),
		getTablesHashref($dummydb),  $dummydb, $database, $dir);
	dropDB($dummydb);
	
	initEverything($database, 1);
	return $ret;
}

###########################################################################
#	sub
#		createDir
#
#	purpose
#		create a new directory.  If you can, else barf
#
sub createDir {
	my ($dir) = @_;
	unless (-e $dir) {
		my $mode = 0777;
		my $result = mkdir $dir, $mode;
		die "error creating $dir: $!" 
			if (!$result and !$OPTIONS{force});
	} else {
		die "$dir already exists" unless $OPTIONS{force};	
	}
	return 1;
}

#############################################################################
#	Function
#		exportNodes
#
#	Purpose
#		This function constructs our everything nodes (table joins, etc)
#		and exports each node in XML format into its own file.  The node
#		XML files are put in directories based on their nodetypes.  For
#		example, the node "root" will be exported to nodes/user/root.xml.
#
#	params
#		nodes - ref to an array of nodes	
#		basedir - the dir to export them to
#		loud - print a message for each node	
#
sub exportNodes
{
	my ($nodes, $basedir, $loud) = @_;
	my %nodetypes=();
	my %nodeindex=();
	my @nodefiles=();

	for(my $i =0; $i < @$nodes;$i++) {
		$_ = $$nodes[$i];
		push @{ $nodetypes{$$_{type}{title}} }, getId($_); 
		$nodeindex{getId($_)}=$i;
	}
	
	foreach my $NODETYPE (keys %nodetypes) {
		my $dir = $NODETYPE;
		
		# convert spaces to '_'. We don't want spaces in the file name.
		$dir =~ tr/ /_/;
		$dir = $basedir.'/'.$dir; 
		createDir $dir unless (-e $dir);	
		foreach my $NODE (@{ $nodetypes{$NODETYPE} }) {
			getRef ($NODE);
			my $file = $$NODE{title};
			$file =~ tr/ /_/;
			
			$file.=".xml";
			
			print "$$NODE{title} ($$NODE{type}{title}) --> $file\n"
				if $OPTIONS{verbose};

			$file = $dir."/".$file; 

			# We want to concat any new stuff onto the end of the file.
			# This way, if the file already exists, we are just adding
			# a new node to the file.
			open(FILE, ">>".$file) 
				or die "couldn't create $file in $dir - do we have permission?";
			print FILE $NODE->toXML();

			close(FILE);

			$nodefiles[$nodeindex{getId($NODE)}]= $file;
		}	
	}
	@nodefiles;
}

########################################################################
#	sub
#		printSettings
#
#	purpose
#		print the settings of the current nodeball
#
sub printSettings {
	my ($VARS) = @_;

	foreach (keys %$VARS) {
		print "$_ :\t$$VARS{$_}\n";	
	}
	print "\n";
}

#######################################################################
#	sub
#		createNodeball
#
#	purpose
#		take a given directory, and tar-gzip it -- as a nodeball
#
#	params
#		dir - directory of stuff
#		NODEBALL - filename to create file for
#
sub createNodeball {
	my ($dir, $NODEBALL) = @_;

	my $VARS = $NODEBALL->getVars();
	my $version = $$VARS{version};
	
	my $filename = $$NODEBALL{title};
	$filename =~ tr/ /_/;
	$filename .= "-$version" if $version;
	$filename .= ".nbz";
	use Cwd;
	my $cwd = getcwd;
	$cwd .= '/' . $filename;

	chdir $dir;
	
	`tar -cvzf $cwd *`;
	chdir getcwd;

	print "\n$filename created\n";
}

###########################################################################
#	sub
#		expandNodeball
#
#	purpose
#		take a tar-gziped nodeball and expand it to a dir in /tmp
#		return the directory

sub expandNodeball {
	my ($nbfile) = @_;

	die "Can't seem to see the nodeball: $nbfile" unless (-e $nbfile);
	my $dir = "/tmp/everything".int(rand(1000));
	createDir($dir);	

	use Cwd;
	my $cwd = getcwd;

	#make the file abs path
	$nbfile = $cwd."/".$nbfile unless ($nbfile =~ /^\//);
	$nbfile = absPath ($nbfile);
	
	chdir $dir;
	my @files = `tar -xvzf $nbfile`;
	if ($OPTIONS{verbose}) {
		foreach (@files) {print $_;}
	}

	chdir $cwd;
	return $dir;
}


###########################################################################
#	sub
#	 	buildNodeballMembers	
#
#	builds a hash of node_id->nodeball that it belongs to.  The nodeball(s)
#	that are sent as parameters are to be discluded.  This way we can
#	see if a node is in more than one nodeball -- where potential conflicts
#	might emerge.  Returns a hash reference
#
#	params:  any nodeball(s) that should be excluded from the hash
#
#
sub buildNodeballMembers {
	my (@EXCLUDES) = @_;
	
	my %excl;
	foreach (@EXCLUDES) {
		$excl{getId($_)} = 1;
	}
	#we build a hash to make lookups easier.

	my $NODEBALLS = getNodeWhere({type_nodetype => getType('nodeball')});
	
	my %nbmembers;
	foreach (@$NODEBALLS) {
		next if $excl{getId($_)};
		my $group = $$_{group};
		foreach my $member (@$group) {
			$nbmembers{$member} = getId($_);	
		}
	}

	return \%nbmembers;
}


############################################################################
#	sub
#		absPath
#
#	get the absolute path of the file or directory
#
sub absPath {
	my ($file) = @_;

	use Cwd;
	my $cwd = getcwd;
	
	#make the file abs path
	$file = $cwd."/".$file unless ($file =~ /^\//);
	return $file;
}

############################################################################
#	sub 
#		cleanUpDir
#
#	purpose
#		removes a specified directory
#
sub cleanUpDir {
	my ($dir) = @_;
	#don't let this bite you in the ass

	return unless (-e $dir and -d $dir and !(-l $dir));
	use File::Path;
	rmtree($dir);
}

#############################################################################
#	sub
#		checkDeps
#
#	purpose	
#		checks dependencies of a node for the given nodeball
#		if there is a dependent node, not in core or in a referenced
#		nodeball dependency, we can throw a warning during export
#
#	params
#		NODEBALL -- the nodeball 
sub checkDeps {
	my ($NODEBALL) = @_;
	
	my %nodes;
	local *buildDeplist = sub {
		my ($NB) = @_;
		getRef($NB);
		return if $nodes{getId($NB)};
		$nodes{getId($NB)}=1;
		foreach (@{ $$NB{group} }) {
			my $NODE = getNode($_);
			next unless ref $NODE;
			$nodes{$NODE->getId()} = 1;
			if ($$NODE{type}{title} eq 'nodeball') {
				buildDeplist($NODE);
			}
		}
	};
	buildDeplist($NODEBALL);

	#we don't care if a dep is in the core
	my $CORE = getNode('core system', 'nodeball');
	my $coregroup = $$CORE{group};
	
	my %inCore;
	foreach (@$coregroup) {
		$inCore{$_} = 1;
	}

	foreach (@{ $$NODEBALL{group} })
	{
		my $NODE = getNode($_);
		next unless(ref $NODE);

		my $exportFields = $NODE->getNodeKeys(1);
		
		foreach my $key (keys %$exportFields)
		{
			next unless ($key =~ /_(\w+)$/ and $1 ne "id"); 
			next unless ($$NODE{$key});

			# eliminate if it's in our dependancies
			next if ($nodes{$$NODE{$key}});

			# warning: this doesn't take into account different core versions
			# eliminate it if it's in the core node
			next if exists($inCore{$$NODE{$key}});

			# Also skip it if it is a -1.  -1 is a flag that it "inherits"
			# (mostly used by nodetypes).
			next if($$NODE{$key} eq "-1");
			
			my $N = getNode($$NODE{$key});	
			print "$$N{title} ($$N{type}{title}) is referenced by " .
				"$$NODE{title}, but is not included as a dependancy\n";
		}
	}
}

############################################################################
#	sub
#		installNodeball
#
sub installNodeball {
	my ($dir) = @_;

	print "Installing nodeball.  Hang on.\n";

	my $tables_dir = $dir."/tables";
	#import any tables that need it
	use File::Find;	

	my (@add_tables, @check_tables);
	if(-e $tables_dir)
	{
		print "Creating tables...\n";
		find sub {
			my ($file) = $File::Find::name;
				if ($file =~ /sql$/) {
					push @add_tables, $file;
				}
			}, $tables_dir;
		print "   - Done.\n";
	}

	my $curr_tables = getTablesHashref($database);
	foreach my $table (@add_tables) {
		next unless ($table =~ m!/(\w+)\.sql$!);
		my $no_path = $1;
		
		if (exists $curr_tables->{$no_path}) {
			print "Skipping already installed table $no_path!\n";
			push @check_tables, $no_path;
			next;
		} else {
			`mysql -u root $database < $table`;
		}
	}

	if (@check_tables) {
		my $check = checkNamedTables(\@check_tables, $tables_dir);
		print "Skipped tables have the right columns, though!\n" if ($check);
	}
	my $nodetypes_dir = $dir."/nodes/nodetype";

	if(-e $nodetypes_dir)
	{
		print "Installing nodetypes...\n";
		find sub {
			my ($file) = $File::Find::name;
			xmlfile2node($file) if $file =~ /\.xml$/;  
			}, $nodetypes_dir if -e $nodetypes_dir;
		print "Fixing references...\n";
		fixNodes(0);
		print "   - Done.\n";
	}

	# Now that the nodetypes are installed, we can install the nodes.
	# But first, we need to flush the entire cache because some nodetypes
	# may have been loaded before their parent nodetypes.  This would
	# result in nodetypes being cached that are not complete.  By flushing
	# the cache, we will reload all the types as they are needed and they
	# will be properly derived.
	$DB->{cache}->flushCache();
	
	print "Installing nodes...\n";
	find sub  {
		my ($file) = $File::Find::name;
		my ($currDir) = $File::Find::dir;
		
		# Don't do the nodetypes again!  We already installed them and fixed
		# some of their references.  If we install them again, they will be
		# broken for the rest of the nodes that we need to install.
		return if($currDir =~ /nodes\/nodetype/);
		
		xmlfile2node($file) if $file =~ /\.xml$/;  
	}, $dir;

	print "Fixing references...\n";
	fixNodes(1);
	print "   - Done.\n";

	# install any .pm's that we might have
	installModules($dir);

	#memo to myself -- we should give warnings if dependant 
	#nodeballs are not installed
}


#############################################################################
#	Sub
#		installModules
#
#	Purpose
#		Copy any perl modules that exist in this nodeball to the appropriate
#		install directory on the system.
#
#	Parameters
#		$dir - the base directory of this nodeball
#
#	Returns
#		1 if something was copied.  0 if no work was done.
#
sub installModules
{
	my ($dir) = @_;
	my $includeDir;
	my $result = 0;

	use File::Find;
	use File::Copy;

	# If there is an Everything directory, we need to install the modules
	# in the system include directory. 
	my $e_dir = $dir;
	$e_dir .= "/" unless($e_dir =~ /\/$/);
	$e_dir .= "Everything";
	return $result unless(-e $e_dir && -d $e_dir);

	$includeDir = getPMDir() . "/Everything";
	
	# Copy all of the pm's to the system directory.
	find sub {
		my ($file) = $File::Find::name;
			if ($file =~ /pm$/)
			{
				print "Copying $file\n   to " . $includeDir . "/" . $_ . "\n";
				copy($file, $includeDir . "/" . $_);
				$result = 1;
			}
		}, $e_dir;

 	return $result;
}


#############################################################################
#	Sub
#		getPMDir
#
#	Purpose
#		When Everything is installed, the base perl modules are installed
#		somewhere on the system.  Where they are installed varies from
#		system to system, but they are always installed somewhere in the
#		standard perl include directories.  This searches through the
#		install directories until we find it.
#
#	Parameters
#		None
#
#	Returns
#		The include directory where Everything.pm and Everthing/ can be
#		found.  undef if we couldn't find it.
#
sub getPMDir
{
	my $includeDir;
	my $edir;
	
	foreach $includeDir (@INC)
	{
		$edir = $includeDir . "/Everything";
		return $includeDir if(-e $edir);
	}

	return undef;
}


#########################################################################
#	sub
#		getFileInfo
#
#	purpose
#		get the title and type of the node for the file we describe
#		returns a hash of the following fields:
#		type -- the nodes type (string)
#		title -- the node's title (string)
#		file -- the filename
#
sub getFileInfo {
	my ($filename) = @_;

	return unless -e $filename and $filename =~ /xml$/;
	
	open XMLFILE, $filename;
	my $xml;
	{
		local $/;
	 	$xml = <XMLFILE>;
	}
	close XMLFILE;

	my %info = ();

	$info{title} = readTag 'title', $xml;
	$info{type} = readTag 'type_nodetype', $xml;
	$info{file} = $filename;
	
	return \%info;
}



############################################################################
#	sub 
#		updateNodeball
#
#	purpose
#		we already have this nodeball in the system, and we need to figure
#		out which files to add, remove, and update
#
sub updateNodeball {
	my ($OLDBALL, $dir) = @_;

	#check the tables and make sure that they're compatable
	my $tabledir = $dir."/tables";
	unless (checkTables ($tabledir) or $OPTIONS{force}) { 
		die "your tables weren't exactly alike.  Change your tables in the "
		."mysql client or use --force";
	}

	my $nodesdir = $dir."/nodes";
	my @nodes = ();
	
	use File::Find;
	find sub {
			my $file = $File::Find::name;
			my $info = getFileInfo $file;
			push @nodes, $info if $info;
	  	}, $nodesdir;

	#check to make sure all dependencies are installed
	
	# create a hash of the old nodegroup -- better lookup times
	my (%oldgroup);
	foreach my $id (@{ $$OLDBALL{group} }) {
		$oldgroup{$id} = getNode($id);
	}
	
	my $nbmembers = buildNodeballMembers($OLDBALL);
	my $new_nbfile;
	foreach my $N (@nodes) {
		if ($$N{type} eq "nodeball" and $$N{title} eq $$OLDBALL{title}) {
			$new_nbfile = $$N{file};	
			next;
		}
		#we'll take care of this later
		
		#we need to get the id of nodes --- 
		#also check any deps	
		my $OLDNODE = getNode($$N{title},$$N{type});
		if ($OLDNODE) {
			if ($oldgroup{getId($OLDNODE)}) {
				delete $oldgroup{getId($OLDNODE)};
			} 
			next if ($$N{type} eq 'nodeball'); #good 
			next if ($$N{type} eq 'user'); #users shouldn't be replaced 
			next if ($$N{type} eq 'usergroup'); #usergroups shoudn't be replaced

			if ($$nbmembers{getId($OLDNODE)}) {
				my $OTHERNB = getNodeById $$nbmembers{getId($OLDNODE)};
				next unless confirmYN("Node $$OLDNODE{title} is also included in the \"$$OTHERNB{title}\" nodeball.  Do you want to replace it (N/y)?");
			}
		
		} else {
			if ($$N{type} eq 'nodeball') {
				print "shoot!  Your nodeball says it needs $$N{title}.  You need to go get that.";
				die unless $OPTIONS{force};
			}
		}
		xmlfile2node $$N{file};
	}
	
	fixNodes(0);
	#fix broken dependancies

	#insert the new nodeball
	my $NB  = xmlfile2node $new_nbfile;
	getRef($NB);
	
	#find the unused nodes and remove them
	foreach (values %oldgroup) {
		my $NODE = getNode($_);

		next unless($NODE);

		#we should probably confirm this
		$NODE->nuke(-1);
	}
	fixNodes(1);

	installModules($dir);
	
	print "$$NB{title} updated.\n";
}


############################################################################
#	sub 
#		removeNodeball
#
#	purpose
#		kill the sucka!
#
sub removeNodeball {
	my ($DOOMEDBALL) = @_;
	# we need the root user so we can nuke nodes successfully
	my $root = $DB->getNode('root', 'user');
	my $doomed_id = $DB->getId($DOOMEDBALL);
	my @members;

	#we should also check dependancies -- am I in any other nodeballs?
	# this technique avoids 'out of memory' errors
	my (@NODEBALLS) = $DB->getNodeWhere( { 1 => 1 }, $DB->getType("nodeball"));
	while (@NODEBALLS) {
		my $NB = shift @NODEBALLS;
		push @members, $NB->{group};
	}

	foreach my $member (@members) {
		foreach (@$member) {
			if ($DB->getId($_) == $doomed_id) {
				my $DEPENDENT = getNode($_);
				my $VARS = $DEPENDENT->getVars(-1);
				die "Nodeball \"$$DEPENDENT{title}\" ($$VARS{version}) " .
				  "depends on $$DOOMEDBALL{title}\n" .
				  "Remove \"$$DEPENDENT{title}\" first, or use --force\n"
				  unless ($OPTIONS{force});
			}
		}
	}

	unless ($OPTIONS{force}) {
		print "Are you sure you want to remove $$DOOMEDBALL{title}?\n";
		my $yesno = <STDIN>;
		exit unless ($yesno =~ /^y/i);
	}
	
	foreach (@{ $$DOOMEDBALL{group} }) {
		my $N = getNode($_);
		next if ($$N{type}{title} eq "nodeball"); #don't remove dependancies
		print "removing \"$$N{title}\" ($$N{type}{title})...\n"
			if $OPTIONS{verbose};
		$N->nuke($root) or print "Remove Error!  I can't nuke $$N{title}!!!\n" ;
	}

	$DOOMEDBALL->nuke($root);
	print "$$DOOMEDBALL{title} removed\n";
}

#############################################################################
#
#	main function
#
sub main {
	
	my ($dir, $cleanme) = ("", "");
	eval {
	if ($function eq "import") {
		my ($nbfile) = $nodeball;

		if (-d $nbfile) {
			$dir = absPath($nbfile);
		} else {
			$dir = expandNodeball $nbfile;
			$cleanme = 1;	
		}

		open NODEBALL, $dir."/ME" or die 
			"Can't find the nodeball link '$dir\/ME'-- try running in " .
			"-V and make sure it's not empty\n";

		my $nodeball_xml = join '', <NODEBALL>;
		close NODEBALL;	
		
		my $settings_xml = readTag ('vars', $nodeball_xml);
		my $version = readTag('version', $settings_xml);
		my $author = readTag('author', $settings_xml);
		my $description = readTag('description', $settings_xml);
		my $title = readTag('title', $nodeball_xml);

		if ($OPTIONS{verbose}) {
			print "\n\ntitle: $title\nversion: $version\nauthor: $author\ndescription:$description\n";

		}

		my $OLDBALL = getNode($title, "nodeball");

		if ($OLDBALL) {
			#we have the same nodeball already installed
			my $VARS = $OLDBALL->getVars();
			my @oldversion = split /\./, $$VARS{version};
			my @newversion = split /\./, $version;

			for (my $i=0; $i < @oldversion; $i++) {
				last if $newversion[$i] > $oldversion[$i];
				die "Your current version of $title ($$VARS{version}) is newer\n"
				."than the version that you are trying to install ($version). \n" 
				."Do --force if you want to force this." 
					if $oldversion[$i] > $newversion[$i] and not $OPTIONS{force}; 	
			}
			die "Your version of $title ($$VARS{version}) is up to date\n"
				."according to the version number, at least.\n"
				."Do --force if you want to force it anyway.\n" 
				if ($version eq $$VARS{version} and not $OPTIONS{force});
			print "updating nodeball $$OLDBALL{title}\n";	
			updateNodeball ($OLDBALL, $dir);
			cleanUpDir($dir) if $cleanme;
			exit;
		} 
		installNodeball ($dir);
		my $errors = getFrontsideErrors;
		if (@$errors and $OPTIONS{verbose}) {
			use Data::Dumper;
			print Dumper(@$errors);
		}
		cleanUpDir($dir) if $cleanme;
	
	} elsif ($function eq "export") {
		my $NB = getNode($nodeball, "nodeball");
		$NB or die "no nodeball $nodeball exists for export!\n";
	
		printSettings ($NB->getVars());
		checkDeps ($NB);

		my $dir = "/tmp/everything".int(rand(1000));
		createDir ($dir);
		
		my @tables;
		foreach my $NODE (@{ $$NB{group} }) {
			getRef ($NODE);
			if ($$NODE{type}{title} eq "dbtable") {
				push @tables, $$NODE{title};
			}
		}
		
		if (@tables) {
			print "exporting table @tables\n";
			my $tabledir .= $dir . "/tables";
			createDir $tabledir;
			exportTables (\@tables, $tabledir);	
  		}

		my $basedir .= $dir ."/nodes"; 
		createDir($basedir);
		my @FILES = exportNodes ([$NB, @{ $$NB{group} }], $basedir, 1);
		
		my $melink = $dir."/ME";
		my $mefile = $FILES[0];
		$mefile =~ s/^$dir/\./;	

		use Cwd; 
		my $cwd = getcwd;
		chdir $dir;
		`ln $mefile $melink`;
		chdir $cwd;
		
		createNodeball($dir, $NB);
		cleanUpDir ($dir);
	} elsif ($function eq "remove") {
		# don't order by anything, but limit the number of rows returned to one
		# maybe not a great idea, but it changes functionality here not at all
		my ($NB) = $DB->getNodeWhere({title=>$nodeball},
			$DB->getType("nodeball"), '', 1);
		# we receive an array ref from getNodeWhere, but we want a single node
		$NB = shift @$NB;
		$NB or 
		  die "There isn't a \"$nodeball\" nodeball installed on this system!";
		removeNodeball ($NB);
	} else {
		print $usagestr;
	}
	};
	print $@ if ($@);
	cleanUpDir($dir) if ($cleanme);
}

main;
